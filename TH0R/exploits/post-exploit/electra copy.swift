//
//  electra.swift
//  Odyssey
//
//  Created by CoolStar on 3/1/20.
//  Copyright © 2020 coolstar. All rights reserved.
//

import Foundation

enum JAILBREAK_RETURN_STATUS {
    case ERR_NOERR
    case ERR_VERSION
    case ERR_EXPLOIT
    case ERR_UNSUPPORED
    case ERR_TFP0
    case ERR_ALREADY_JAILBROKEN
    case ERR_ROOTFS_RESTORE
    case ERR_REMOUNT
    case ERR_SNAPSHOT
    case ERR_JAILBREAK
    case ERR_CONFLICT
}

protocol ElectraUI {
    func showAlert(_ title: String, _ message: String, sync: Bool, callback: (() -> Void)?, yesNo: Bool, noButtonText: String?)
}

class Electra {
    #if MAINAPP
    private let ui: ElectraUI
    #endif
    private let tfp0: mach_port_t
    #if MAINAPP
    private let any_proc: UInt64
    private let enable_tweaks: Bool
    private let restore_rootfs: Bool
    private let nonce: String
    #endif
    
    private let offsets = Offsets.shared
    private let consts = Consts.shared
    
    #if MAINAPP
    private var kernel_slide: UInt64 = 0
    #endif
    
    private var all_proc: UInt64 = 0
    
    private(set) var our_proc: UInt64 = 0
    private var launchd_proc: UInt64 = 0
    private var kernel_proc: UInt64 = 0
    
    private(set) var amfid_pid: UInt32 = 0
    private(set) var jailbreakd_pid: UInt32 = 0
    #if MAINAPP
    private(set) var cfprefsd_pid: UInt32 = 0
    #endif
    
    private var our_task_addr: UInt64 = 0
    #if MAINAPP
    private var our_label: UInt64 = 0
    
    private var root_vnode: UInt64 = 0
    
    public init(ui: ElectraUI, tfp0: mach_port_t, any_proc: UInt64, enable_tweaks: Bool, restore_rootfs: Bool, nonce: String) {
        self.ui = ui
        self.tfp0 = tfp0
        self.any_proc = any_proc
        self.enable_tweaks = enable_tweaks
        self.restore_rootfs = restore_rootfs
        self.nonce = nonce
    }
    #else
    public init(tfp0: mach_port_t, all_proc: UInt64) {
        self.tfp0 = tfp0
        self.all_proc = all_proc
    }
    #endif
    
    #if MAINAPP
    private func find_allproc() {
        var proc = any_proc
        while proc != 0 {
            if rk64(rk64(proc + 8)) != proc {
                //print(String(format: "Allproc? 0x%llx", proc))
                all_proc = proc
                break
            }
            proc = rk64(proc + 8)
        }
    }
    
    public func findPort(port: mach_port_name_t) -> UInt64 {
        let ourTask = rk64(self.our_proc + offsets.proc.task)
        let itkSpace = rk64(ourTask + offsets.task.itk_space)
        let isTable = rk64(itkSpace + offsets.ipc_space.is_table)
        
        let portIndex = UInt32(port) >> 8
        let ipcEntrySz = UInt32(0x18)
        
        let portAddr = rk64(isTable + UInt64((portIndex * ipcEntrySz)))
        return portAddr
    }
    #endif
    
    public func populate_procs() {
        let our_pid = getpid()
        var proc = rk64(all_proc)
        while proc != 0 {
            let pid = rk32(proc + offsets.proc.pid)
            if pid == 0 {
                kernel_proc = proc
                #if MAINAPP || DEBUG
                //print("found kernel proc")
                #endif
            } else if pid == our_pid {
                #if MAINAPP || DEBUG
                //print("found our pid")
                #endif
                //usleep(100)
                our_proc = proc
                our_task_addr = rk64(proc + offsets.proc.task)
                
                let our_flags = rk32(our_task_addr + offsets.task.flags)
                wk32(our_task_addr + offsets.task.flags, our_flags | consts.TF_PLATFORM)
                
                var our_csflags = rk32(our_proc + offsets.proc.csflags)
                our_csflags = our_csflags | consts.CS_PLATFORM_BINARY | consts.CS_INSTALLER | consts.CS_GET_TASK_ALLOW
                our_csflags &= ~(consts.CS_RESTRICT | consts.CS_HARD | consts.CS_KILL)
                wk32(our_proc + offsets.proc.csflags, our_csflags)
            } else if pid == 1 {
                #if MAINAPP || DEBUG
                //print("found launchd")
                #endif
                
                launchd_proc = proc
            } else {
                let nameptr = proc + offsets.proc.name
                var name = [UInt8](repeating: 0, count: 32)
                kread(nameptr, &name, 32)
                //print("found proc name: ", String(cString: &name))
                
                let swiftName = String(cString: &name)
                if swiftName == "amfid" {
                    #if MAINAPP || DEBUG
                    //print("found amfid")
                    #endif
                    amfid_pid = pid
                } else if swiftName == "cfprefsd" {
                    #if MAINAPP || DEBUG
                    //print("found cfprefsd")
                    #endif
                    #if MAINAPP
                    cfprefsd_pid = pid
                    #endif
                } else if swiftName == "jailbreakd" || swiftName == "substrated" || swiftName == "substituted" {
                    #if MAINAPP || DEBUG
                    //print("found jailbreakd (\(swiftName))")
                    #endif
                    jailbreakd_pid = pid
                }
            }
            proc = rk64(proc)
        }
    }
    
    public func find_proc(pid: UInt32) -> UInt64 {
        var proc = rk64(all_proc)
        while proc != 0 {
            let proc_pid = rk32(proc + offsets.proc.pid)
            if proc_pid == pid {
                return proc
            }
            proc = rk64(proc)
        }
        return proc
    }
    
    #if MAINAPP
    private func getRoot() -> JAILBREAK_RETURN_STATUS {
        let kern_ucred = rk64(kernel_proc + offsets.proc.ucred)
        let self_ucred = rk64(our_proc + offsets.proc.ucred)
        
        let our_label = rk64(self_ucred + offsets.ucred.cr_label)
        wk64(self_ucred + offsets.ucred.cr_label, rk64(kern_ucred + offsets.ucred.cr_label))
        wk32(self_ucred + offsets.ucred.cr_svuid, UInt32(0))
        
        setuid(0)
        setuid(0)
        
        wk64(self_ucred + offsets.ucred.cr_label, our_label)
        
        guard getuid() == 0 else {
            return .ERR_JAILBREAK
        }
        return .ERR_NOERR
    }
    
    private func cleanupCreds() {
        setuid(501)
        print("Reset creds")
    }
    
    public func jailbreak() -> JAILBREAK_RETURN_STATUS {
        print("Starting TH{}R...")
        guard tfp0 != MACH_PORT_NULL else { return .ERR_TFP0 }
        let mobile_realhost = mach_host_self()
        var err: JAILBREAK_RETURN_STATUS = .ERR_NOERR
        find_allproc()
        populate_procs()
        if jailbreakd_pid != 0 { return .ERR_ALREADY_JAILBROKEN }
        let slide = getKernSlide(our_proc: our_proc)// justaslide(mykslide)//mykslide //
        //print(String(format: "kernel slide is at 0x%016llx", slide))
        kernel_slide = slide
        mykslide = slide
        //print(String(format: "our proc is at 0x%016llx", our_proc))
        //print(String(format: "kern proc is at 0x%016llx", kernel_proc))
        err = getRoot()
        if err != .ERR_NOERR { return err }
        defer { cleanupCreds() }
        //print(String(format: "our uid is %d", getuid()))
        let nvram = NVRamUtil(electra: self)
        _ = nvram.setNonce(nonce: nonce) //Not fatal is nonce setting fails
        let remount = Remount(ui: ui, our_proc: our_proc, kernel_proc: kernel_proc)
        if !remount.remount(launchd_proc: launchd_proc) { return .ERR_REMOUNT }
//        _ = SetHSP4(electra: self, tfp0: tfp0, slide: slide, kernel_proc: kernel_proc, our_proc: our_proc, old_realhost: mobile_realhost)
        guard init_kernel(slide + UInt64(0xFFFFFFF007004000), nil) == 0 else {
            return .ERR_JAILBREAK }
        let genCountAddr = find_cs_blob_generation_count()
        term_kernel()
        try? FileManager.default.removeItem(atPath: "/odyssey")
        try? FileManager.default.removeItem(atPath: "/pwnremover")

        unlink("/odyssey/pspawn_payload.dylib")
        unlink("/usr/lib/pspawn_payload-stg2.dylib")
        unlink("/private/var/containers/Bundle/jb_resources")
        unlink("/private/var/jb")
        if #available(iOS 13.5.1, *) {
            let amfidtakeover = AmfidTakeover(electra: self)
            guard amfidtakeover.grabEntitlements(our_proc: our_proc) else {
                return .ERR_JAILBREAK
            }
            amfidtakeover.takeoverAmfid(amfid_pid: amfid_pid)
            makeodddss()
            makepwn()
            //safepatch_swap_unsandbox_and_root()
            guard extractZstd(source: "tar", dest: "/odyssey/tar") else {
                return .ERR_JAILBREAK
            }
            try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "signcert", withExtension: "p12")!,
                                              to: URL(fileURLWithPath: "/odyssey/signcert.p12"))
            try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "uicache", withExtension: "tar")!,
                                              to: URL(fileURLWithPath: "/pwnremover/uicache.tar"))
            try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "zeusstrap", withExtension: "tar.gz")!,
                                              to: URL(fileURLWithPath: "/pwnremover/zeusstrap.tar.gz"))
            try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "gzip", withExtension: "tar")!,
                                              to: URL(fileURLWithPath: "/pwnremover/gzip.tar"))

            shmodtar()
            guard untaramfidebilitate() else { return .ERR_JAILBREAK }
            guard untaramfidbypassd() else { return .ERR_JAILBREAK }
            shmodeverything()
            guard untarb12shot() else { return .ERR_JAILBREAK }
            modsymlink_binbag()
            guard untarkillme() else { return .ERR_JAILBREAK }
            guard untarBasebins() else { return .ERR_JAILBREAK }

            rename("/odyssey/pspawn_payload-stg2.dylib", "/usr/lib/pspawn_payload-stg2.dylib")

            amfidtakeover.resetEntitlements(our_proc: our_proc)
            //print("Waiting for amfi to really be debilitated...")
            while testUnsandboxedExec() != 0 {
                usleep(1000)
            }

            extract_bootstrap()
            if FileManager.default.fileExists(atPath: "/private/private/") {
                try? FileManager.default.removeItem(atPath: "/private/private")
            }
            if restore_rootfs {
                pleaseselectthetruth = 1
                try? FileManager.default.removeItem(atPath: "/.bootstrapped_Th0r4")
                cleanUPhostFile()
                thesnap()
                if !remount.restore_rootfs() { return .ERR_ROOTFS_RESTORE }
                return .ERR_NOERR }
            if FileManager.default.fileExists(atPath: "/usr/lib/libsubstitute.dylib") &&  !FileManager.default.fileExists(atPath: "/Th0r") {
                if pleaseselectthetruth == 1 {
                    guard untarcache2Od() else { return .ERR_JAILBREAK }
                    guard untarcache2pwn() else { return .ERR_JAILBREAK }
                    cleanUPhostFile()
                    thesnap()
                    if !remount.restore_rootfs() { return .ERR_ROOTFS_RESTORE }
                    return .ERR_NOERR }}
            if FileManager.default.fileExists(atPath: "/odyssey") &&  !FileManager.default.fileExists(atPath: "/Th0r") {
                if pleaseselectthetruth == 1 {
                    guard untarcache2Od() else { return .ERR_JAILBREAK }
                    guard untarcache2pwn() else { return .ERR_JAILBREAK }
                    cleanUPhostFile()
                    thesnap()
                    if !remount.restore_rootfs() { return .ERR_ROOTFS_RESTORE }
                    return .ERR_NOERR }}
            
            _ = SetHSP4(electra: self, tfp0: tfp0, slide: slide, kernel_proc: kernel_proc, our_proc: our_proc, old_realhost: mobile_realhost)

            
            patch_codesign()
            if file_exist("/.bootstrapped_Th0r4") && file_exist("/Th0r") { print("TH{}R swords and hammers drawn")
                loadslide()
            } else {
                guard untarcache2Od() else { return .ERR_JAILBREAK }
                guard untarcache2pwn() else { return .ERR_JAILBREAK }
                try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "Deeznutzdebs", withExtension: "tar")!,
                                                  to: URL(fileURLWithPath: "/pwnremover/Deeznutzdebs.tar"))
                try? FileManager.default.removeItem(atPath: "/odyssey/bin/tar")
                try? FileManager.default.removeItem(atPath: "/odyssey/bin/uname")
                loadslide()
                installdebians()
                Acache4theages()
                guard bootstrapDevice(ui: self.ui) else {
                    return .ERR_JAILBREAK
                }
                makeTh0r()
                rename("/pwnremover/killall", "/Th0r/killall")

            }
            if enable_tweaks {
                unlink("/.disable_tweakinject");unlink("/var/tmp/.substrated_disable_loader")} else {
                    try? "".write(toFile: "/.disable_tweakinject", atomically: false, encoding: .utf8)
                    try? "".write(toFile: "/var/tmp/.substrated_disable_loader", atomically: false, encoding: .utf8)}
            var springboardPlist: [String: Any] = [:]
            let plistURL = URL(fileURLWithPath: "/private/var/mobile/Library/Preferences/com.apple.springboard.plist")
            if let plistData = try? Data(contentsOf: plistURL) {
                if let springboardPlistRaw = try? PropertyListSerialization.propertyList(from: plistData, options: .mutableContainersAndLeaves, format: nil) as? [String: Any] {
                    springboardPlist = springboardPlistRaw
                }
            }
            springboardPlist["SBShowNonDefaultSystemApps"] = true
            if let data = try? PropertyListSerialization.data(fromPropertyList: springboardPlist, format: .binary, options: 0) {
                try? data.write(to: plistURL)
            }
            
            try? FileManager.default.setAttributes([FileAttributeKey.posixPermissions: 0755,
                                               FileAttributeKey.ownerAccountName: "mobile"], ofItemAtPath: plistURL.path)
            
            kill(pid_t(cfprefsd_pid), SIGKILL)
            startDaemons()
            startsshing()

            if FileManager.default.fileExists(atPath: "/.bootstrapped_Th0r4") {
                //modsymlink_binbag()
                print("⚔️... PEW PEW ...⚔️")
                letskillliterallyeverythingneeded()
                print("KILLALL")
                //letskillall()
                blockprocursusRepo()
                print("KILLALL")
                print("my uid:", getuid())
                justanODkill()
                try? FileManager.default.removeItem(atPath: "/odyssey/bin/")
                try? FileManager.default.removeItem(atPath: "/odyssey/pwnny/")
                try? FileManager.default.removeItem(atPath: "/odyssey/usr/")
                try? FileManager.default.removeItem(atPath: "/pwnremover/")
                try? FileManager.default.removeItem(atPath: "/odyssey/tar/")
                exit(1)
            }
            
            return err

        } else {
//
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //
            //IOS 13.5 BELOW ONLY /// JAILBREAKD WORKS HERE// //    //  //

            let amfidtakeover = AmfidTakeover(electra: self)
            guard amfidtakeover.grabEntitlements(our_proc: our_proc) else {
               return .ERR_JAILBREAK
            }
            amfidtakeover.takeoverAmfid(amfid_pid: amfid_pid)
            
            _ = SetHSP4(electra: self, tfp0: tfp0, slide: slide, kernel_proc: kernel_proc, our_proc: our_proc, old_realhost: mobile_realhost)
            
            try? FileManager.default.removeItem(atPath: "/odyssey")

            makeodddss()
            makepwn()
            unlink("/odyssey/pspawn_payload.dylib")
            unlink("/usr/lib/pspawn_payload-stg2.dylib")
            
            //safepatch_swap_unsandbox_and_root()
            guard extractZstd(source: "tar", dest: "/odyssey/tar") else {
               return .ERR_JAILBREAK
            }
            try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "zeusstrap", withExtension: "tar.gz")!,
                                              to: URL(fileURLWithPath: "/pwnremover/zeusstrap.tar.gz"))
            try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "signcert", withExtension: "p12")!,
                                              to: URL(fileURLWithPath: "/odyssey/signcert.p12"))
            try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "uicache", withExtension: "tar")!,
                                              to: URL(fileURLWithPath: "/pwnremover/uicache.tar"))
            try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "gzip", withExtension: "tar")!,
                                              to: URL(fileURLWithPath: "/pwnremover/gzip.tar"))

            shmodtar()
            guard untarBasebins() else { return .ERR_JAILBREAK }
            shmodeverything()
            guard untaramfidebilitate() else { return .ERR_JAILBREAK }
            guard untarb12shot() else { return .ERR_JAILBREAK }
            modsymlink_binbag()
            rename("/odyssey/pspawn_payload-stg2.dylib", "/usr/lib/pspawn_payload-stg2.dylib")
            extract_bootstrap()

            if FileManager.default.fileExists(atPath: "/private/private/") {
                try? FileManager.default.removeItem(atPath: "/private/private")
            }

            if restore_rootfs { pleaseselectthetruth = 1
                try? FileManager.default.removeItem(atPath: "/.bootstrapped_Th0r4")
                cleanUPhostFile()
                thesnap()
                if !remount.restore_rootfs() { return .ERR_ROOTFS_RESTORE }
                return .ERR_NOERR }
            if FileManager.default.fileExists(atPath: "/usr/lib/libsubstitute.dylib") && !FileManager.default.fileExists(atPath: "/Th0r") {
                if pleaseselectthetruth == 1 {
                    cleanUPhostFile()
                    thesnap()
                    if !remount.restore_rootfs() { return .ERR_ROOTFS_RESTORE }
                    return .ERR_NOERR }}
            if FileManager.default.fileExists(atPath: "/odyssey") &&  !FileManager.default.fileExists(atPath: "/Th0r") {
                if pleaseselectthetruth == 1 {
                    cleanUPhostFile()
                    thesnap()
                    if !remount.restore_rootfs() { return .ERR_ROOTFS_RESTORE }
                    return .ERR_NOERR }}
            guard amfidtakeover.spawnAmfiDebilitate(allProc: all_proc) else { return .ERR_JAILBREAK }
            print("waiting for amfidebilitate...")
            while !amfidtakeover.amfidebilitate_spawned {
                usleep(10000)
                print("waiting amfidebilitate...") }
            amfidtakeover.resetEntitlements(our_proc: our_proc)
            print("Waiting for amfi to really be debilitated...")
            while testUnsandboxedExec() != 0 {
                print("testUnsandboxedExec......")
                usleep(1000)
            }
            guard spawnJailbreakd(genCountAddr: genCountAddr) else { return .ERR_JAILBREAK }
            while !FileManager.default.fileExists(atPath: "/private/var/run/jailbreakd.pid") {
                print("Waiting for a jailbreakd...")
                usleep(100000)
            }
            if file_exist("/.bootstrapped_Th0r4") && file_exist("/Th0r") {
                loadslide()
                print("TH{}R swords and hammers drawn")
            } else {
                try? FileManager.default.copyItem(at: Bundle.main.url(forResource: "Deeznutzdebs", withExtension: "tar")!,
                                                  to: URL(fileURLWithPath: "/pwnremover/Deeznutzdebs.tar"))
                try? FileManager.default.removeItem(atPath: "/odyssey/bin/tar")
                try? FileManager.default.removeItem(atPath: "/odyssey/bin/uname")
                loadslide()
                installdebians()
                Acache4theages()
                guard bootstrapDevice(ui: self.ui) else {
                    return .ERR_JAILBREAK
                }

                makeTh0r()
            }
            
            if enable_tweaks {
                unlink("/.disable_tweakinject");unlink("/var/tmp/.substrated_disable_loader")} else {
                    try? "".write(toFile: "/.disable_tweakinject", atomically: false, encoding: .utf8)
                    try? "".write(toFile: "/var/tmp/.substrated_disable_loader", atomically: false, encoding: .utf8)}
            var springboardPlist: [String: Any] = [:]
            let plistURL = URL(fileURLWithPath: "/private/var/mobile/Library/Preferences/com.apple.springboard.plist")
            if let plistData = try? Data(contentsOf: plistURL) {
                if let springboardPlistRaw = try? PropertyListSerialization.propertyList(from: plistData, options: .mutableContainersAndLeaves, format: nil) as? [String: Any] {
                    springboardPlist = springboardPlistRaw
                }
            }
            springboardPlist["SBShowNonDefaultSystemApps"] = true
            if let data = try? PropertyListSerialization.data(fromPropertyList: springboardPlist, format: .binary, options: 0) {
                try? data.write(to: plistURL)
            }
            
            try? FileManager.default.setAttributes([FileAttributeKey.posixPermissions: 0755,
                                               FileAttributeKey.ownerAccountName: "mobile"], ofItemAtPath: plistURL.path)
            
            kill(pid_t(cfprefsd_pid), SIGKILL)
            blockprocursusRepo()
            startDaemons()
            
            if FileManager.default.fileExists(atPath: "/.bootstrapped_Th0r4") {
                print("⚔️... PEW PEW ...⚔️")

                _ = prepareUserspaceReboot(allProc: all_proc, genCountAddr: genCountAddr)
                                
                _ = runUnsandboxed(cmd: "killall -9 runningboardd")//this makes camera work again alone
                _ = runUnsandboxed(cmd: "killall -9 applecamerad videosubscriptionsd mediaserverd runningboardd")
                _ = runUnsandboxed(cmd: "killall -9 /Applications/AppStore.App/AppStore")
                _ = runUnsandboxed(cmd: "killall -9 appstored")
                
                try? FileManager.default.removeItem(atPath: "/odyssey/bin/")
                try? FileManager.default.removeItem(atPath: "/odyssey/pwnny/")
                try? FileManager.default.removeItem(atPath: "/odyssey/usr/")
                try? FileManager.default.removeItem(atPath: "/pwnremover/")
                try? FileManager.default.removeItem(atPath: "/odyssey/tar/")
                
                let files = [
                    "/sbin/launchd",
                    "/usr/libexec/xpcproxy",
                    "/odyssey/amfidebilitate",
                    "/odyssey/jailbreakd",
                    "/usr/libexec/keybagd",
                    "/odyssey/pspawn_payload.dylib"
                ]
                for file in files {
                    retainFile(file: file, our_proc: our_proc)
                }
                _ = preflightExecutable(exec: "/sbin/launchd")
                _ = preflightExecutable(exec: "/usr/libexec/keybagd")
                _ = runUnsandboxed(cmd: "DYLD_INSERT_LIBRARIES=/odyssey/pspawn_payload.dylib /usr/libexec/xpcproxy")
                
                justanODkill()
            }
            return err
        }
        
    }
    
    private func spawnJailbreakd(genCountAddr: UInt64) -> Bool {
        let allProcStr = String(format: "0x%llx", all_proc)
        let genCountAddrStr = String(format: "0x%llx", genCountAddr)
        
        let launchdPlist: [String: Any] = [
            "KeepAlive": true,
            "RunAtLoad": true,
            "UserName": "root",
            "Program": "/odyssey/jailbreakd",
            "Label": "jailbreakd",
            "POSIXSpawnType": "Interactive",
            "EnvironmentVariables": [
                "allProc": allProcStr,
                "genCountAddr": genCountAddrStr
            ],
            "MachServices": [
                "org.coolstar.jailbreakd": [
                    "HostSpecialPort": 15
                ]
            ]
        ]
        let plistData = try? PropertyListSerialization.data(fromPropertyList: launchdPlist, format: .binary, options: .zero)
        try? plistData?.write(to: URL(fileURLWithPath: "/odyssey/jailbreakd.plist"))
        
        let dict = xpc_dictionary_create(nil, nil, 0)
        
        var str = xpc_string_create("/odyssey/jailbreakd.plist")
        let paths = xpc_array_create(&str, 1)
        
        xpc_dictionary_set_value(dict, "paths", paths)
        xpc_dictionary_set_uint64(dict, "subsystem", 3)
        xpc_dictionary_set_bool(dict, "enable", true)
        xpc_dictionary_set_uint64(dict, "type", 1)
        xpc_dictionary_set_uint64(dict, "handle", 0)
        xpc_dictionary_set_uint64(dict, "routine", UInt64(ROUTINE_LOAD))
        
        var outDict: xpc_object_t?
        let rc = xpc_pipe_routine(xpc_bootstrap_pipe(), dict, &outDict)
        if rc == 0,
            let outDict = outDict {
            let rc2 = Int32(xpc_dictionary_get_int64(outDict, "error"))
            if rc2 != 0 {
                print(String(format: "Error submitting service: %s", xpc_strerror(rc2)))
                return false
            }
        } else if rc != 0 {
            print(String(format: "Error submitting service (no outdict): %s", xpc_strerror(rc)))
            return false
        }
        return true
    }
    #endif
}
